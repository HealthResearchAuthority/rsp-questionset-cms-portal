using Microsoft.AspNetCore.Mvc;
using Rsp.QuestionSetPortal.Helpers;
using Rsp.QuestionSetPortal.Models;
using Rsp.QuestionSetPortal.Models.Modifications;
using Rsp.QuestionSetPortal.Services;
using Umbraco.Cms.Core;
using Umbraco.Cms.Web.Common.PublishedModels;

namespace Rsp.QuestionSetPortal.Controllers;

[ApiController]
[Route("/umbraco/api/[controller]/[action]")]
public class ModificationsQuestionsetController
(
    IModificationQuestionSetService questionSetService,
    IPublishedContentQuery contentQuery
) : ControllerBase
{
    [HttpGet]
    public QuestionSetModel GetQuestionSet(string? sectionId = null, string? questionSetId = null, string? version = null)
    {
        var result = new QuestionSetModel();

        if (!string.IsNullOrEmpty(sectionId))
        {
            var activeQuestionSet = questionSetService.GetQuestionsetByVersion(version);

            var section = activeQuestionSet?
                .Descendants<Section>()
                .FirstOrDefault
                (
                    section =>
                        section.SectionId?.Equals(sectionId, StringComparison.InvariantCultureIgnoreCase) == true
                );

            if (activeQuestionSet == null || section == null)
            {
                return result;
            }

            ContentHelpers.PopulateGeneralQuestionSetMetadata(result, activeQuestionSet);

            var sectionModel = ContentHelpers.PopulateSectionModel(section);

            sectionModel.Questions = ContentHelpers.TransformQuestions(section, result.Version);

            result.Sections.Add(sectionModel);
        }
        else
        {
            if (string.IsNullOrEmpty(questionSetId))
            {
                // no id passed so go ahead and get the active questionset
                var activeQuestionSet = questionSetService.GetQuestionsetByVersion(version);

                if (activeQuestionSet != null)
                {
                    questionSetId = activeQuestionSet.Key.ToString();

                    ContentHelpers.PopulateGeneralQuestionSetMetadata(result, activeQuestionSet);
                }
            }

            if (!string.IsNullOrEmpty(questionSetId))
            {
                var questionSet = contentQuery.Content(questionSetId) as ModificationsQuestionSet;

                ContentHelpers.PopulateGeneralQuestionSetMetadata(result, questionSet);

                var sections = questionSet?.Descendants<Section>();

                if (sections != null)
                {
                    foreach (var section in sections)
                    {
                        var sectionModel = ContentHelpers.PopulateSectionModel(section);

                        sectionModel.Questions = ContentHelpers.TransformQuestions(section, result.Version);

                        result.Sections.Add(sectionModel);
                    }
                }
            }
        }

        return result;
    }

    [HttpGet]
    public StartingQuestionsModel GetStartingQuestions(string? version = null)
    {
        var result = new StartingQuestionsModel();
        var activeQuestionSet = questionSetService.GetQuestionsetByVersion(version);

        if (activeQuestionSet != null)
        {
            var questionSetNode = contentQuery.Content(activeQuestionSet.Key);

            if (questionSetNode != null)
            {
                var areaOfChange = questionSetNode.FirstChild<AreaOfChangeQuestion>();

                if (areaOfChange != null)
                {
                    var answerOptions = areaOfChange.Children<AnswerOption>();

                    result.AreasOfChange = answerOptions.Select(option => new AreaOfChangeModel()
                    {
                        AutoGeneratedId = option.Key.ToString(),
                        Id = option.OptionId,
                        OptionName = option.OptionName,
                        SpecificAreasOfChange = option.Children<SubAnswerOption>().Select(suboption => new AnswerModel
                        {
                            AutoGeneratedId = suboption.Key.ToString(),
                            Id = suboption.OptionId,
                            OptionName = suboption.OptionName,
                            ShowApplicabilityQuestions = suboption.ShowApplicabilityQuestions
                        }).ToList()
                    }).ToList();
                }
            }
        }

        return result;
    }

    [HttpGet]
    public QuestionSetModel GetModificationsJourney(string specificChangeId, string? version = null)
    {
        var result = new QuestionSetModel();

        var activeQuestionSet = questionSetService.GetQuestionsetByVersion(version);
        if (activeQuestionSet == null)
        {
            return result;
        }

        ContentHelpers.PopulateGeneralQuestionSetMetadata(result, activeQuestionSet);
        var journeys = activeQuestionSet.Children<ModificationJourney>();
        var activeJourney = journeys?.FirstOrDefault(x => x.Condition?.Any(x => x.Key.ToString() == specificChangeId) == true);

        var children = activeJourney?.Children<Section>();

        if (children is null)
        {
            return result;
        }

        foreach (var section in children)
        {
            var sectionModel = new SectionModel
            {
                SectionName = section.SectionName,
                Id = section.SectionId,
                CategoryId = section.Category?.Name,
                AutoGeneratedId = section.Key.ToString(),
                GuidanceComponents = section.GuidanceContent != null ? ContentHelpers.TransformUiComponent(section.GuidanceContent) : [],
                Questions = ContentHelpers.TransformQuestions(section, version),
                StaticViewName = section.StaticViewName,
                IsMandatory = section.Mandatory,
                Sequence = section.Sequence,
                IsLastSectionBeforeReview = section.IsLastSectionBeforeReview,
                EvaluateBackRoute = section.EvaluateBackRoute,
                StoreUrlReferrer = section.StoreReferrer
            };

            result.Sections.Add(sectionModel);
        }

        return result;
    }

    [HttpGet]
    public QuestionSectionResponse? GetNextQuestionSection(string currentSectionId, string? version = null, string? parentQuestionId = null, string? parentAnswerOption = null)
    {
        return FindSection(currentSectionId, 1, version, parentQuestionId, parentAnswerOption);
    }

    [HttpGet]
    public QuestionSectionResponse? GetPreviousQuestionSection(string currentSectionId, string? version = null, string? parentQuestionId = null, string? parentAnswerOption = null)
    {
        return FindSection(currentSectionId, -1, version, parentQuestionId, parentAnswerOption);
    }

    /// <summary>
    /// Finds the next or previous section in a modification journey based on the current section and offset.
    /// Optionally, can locate a section by parent question and answer option.
    /// </summary>
    /// <param name="currentSectionId">The section ID of the current section.</param>
    /// <param name="indexOffset">Offset for navigation: 1 for next, -1 for previous.</param>
    /// <param name="version">Optional version of the question set.</param>
    /// <param name="parentQuestionId">Optional parent question ID for conditional navigation.</param>
    /// <param name="parentAnswerOption">Optional parent answer option for conditional navigation.</param>
    /// <returns>
    /// A <see cref="QuestionSectionResponse"/> representing the target section, or null if not found.
    /// </returns>
    private QuestionSectionResponse? FindSection(string currentSectionId, int indexOffset, string? version = null, string? parentQuestionId = null, string? parentAnswerOption = null)
    {
        // Validate input
        if (string.IsNullOrEmpty(currentSectionId))
        {
            return null;
        }

        // Retrieve the question set for the specified version
        var questionset = questionSetService.GetQuestionsetByVersion(version);

        // Find the current section by its ID
        var currentSection = questionset?
           .Descendants<Section>()
           .FirstOrDefault
           (
               section =>
                    !string.IsNullOrEmpty(section.SectionId) &&
                    section.SectionId.Equals(currentSectionId, StringComparison.InvariantCultureIgnoreCase)
           );

        // Get all sections in the current journey
        if (currentSection is null ||
            currentSection.Parent<ModificationJourney>()?.Children<Section>() is not IEnumerable<Section> allSections)
        {
            return null;
        }

        // Find the index of the current section
        var currentSectionIndex = allSections.FindIndex(x => x.Key == currentSection.Key);

        var targetSectionIndex = currentSectionIndex + indexOffset;

        // Calculate the target section index using the offset
        if (indexOffset == 1 && currentSection.NextSection is not null)
        {
            targetSectionIndex =
                allSections.FindIndex(x => x.Key == currentSection.NextSection.Key);
        }

        // If parent question and answer option are provided, find the section matching those
        else if (parentQuestionId != null && parentAnswerOption != null)
        {
            var options = parentAnswerOption.Split([",", "<br/>"], StringSplitOptions.RemoveEmptyEntries);

            targetSectionIndex =
            (
                from section in allSections
                let slot = section.ParentQuestion as QuestionSlot
                let answerOptions = section.ParentAnswerOption
                where
                    section.Key != currentSection.Key &&
                    slot?.QuestionId == parentQuestionId &&
                    answerOptions?.Select(option => (option as AnswerOption)?.OptionName).Intersect(options).Any() is true
                select allSections.IndexOf(section)
            ).SingleOrDefault();
        }

        // when finding the previous section, we need to consider
        // if current section is linked to the parent question, and so it should go back to that section
        if (indexOffset == -1 && currentSection.ParentQuestion is QuestionSlot parentQuestionSlot)
        {
            var section = parentQuestionSlot.Parent<Section>();

            if (section != null)
            {
                targetSectionIndex = allSections.FindIndex(x => x.Key == section.Key);
            }
        }

        // Get the target section by index
        var targetSection = allSections.ElementAtOrDefault(targetSectionIndex);

        if (targetSection != null)
        {
            var sectionCategory = targetSection.Category as Category;

            // Return the response with section details
            return new QuestionSectionResponse
            {
                SectionId = targetSection.SectionId,
                SectionName = targetSection.SectionName?.ToString(),
                QuestionCategoryId = sectionCategory?.CategoryId,
                StaticViewName = targetSection.StaticViewName,
                IsMandatory = targetSection.Mandatory,
                Sequence = targetSection.Sequence,
                IsLastSectionBeforeReview = targetSection.IsLastSectionBeforeReview
            };
        }

        return null;
    }
}